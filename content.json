{"meta":{"title":"HeilantG's Blog","subtitle":null,"description":null,"author":"HeilantG","url":"http://yoursite.com"},"pages":[{"title":"","date":"2019-02-20T11:10:28.390Z","updated":"2019-02-20T11:10:20.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2019-02-20T11:09:50.796Z","updated":"2019-02-20T11:09:44.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JSP学习日记01","slug":"JSP学习日记01","date":"2019-05-12T02:47:33.000Z","updated":"2019-05-12T04:14:18.288Z","comments":true,"path":"2019/05/12/JSP学习日记01/","link":"","permalink":"http://yoursite.com/2019/05/12/JSP学习日记01/","excerpt":"学习JSP已经一周了(其实都是老师上课讲的,我自己下去完全没有学..).然后这篇博客将记录这一周的所学","text":"学习JSP已经一周了(其实都是老师上课讲的,我自己下去完全没有学..).然后这篇博客将记录这一周的所学. 什么是JSP,它和JavaScript有什么关系?第一次听到JS和JSP的时候,我以为二者有一定的附属关系,但是二者可以说完全没有关系.JS是镶嵌在网页之中的代码,执行者是客户端(浏览器),而JSP的执行者是服务端.虽然JSP也可以写在网页之中,但是极其不建议将它写在网页中,这样会造成代码混乱可供JSP进行执行操作的网页后缀不再是 .html 而是 .jsp 它与html并没有太多不同,可以说就是html的一个拓展,仅仅是再第一行加入了 JSP首行的意义1&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;pageEncoding=&quot;UTF-8&quot;%&gt; 这一行的作用就是声名JSP页面的服务端语言是java,页面语言是html,同时指定编码格式. JavaWeb三层结构 三层结构 servlet 层servlet层是用来处理JSP页面数据,同时使其与其他代码块(server层)进行交互的.它拥有自己的特殊写法,先看代码。1234567891011121314151617181920212223242526272829303132333435363738394041public class UsersServlet extends HttpServlet &#123; // 业务层对象 UsersService ser = new UsersService(); @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 1.接受参数 String name = req.getParameter(&quot;uname&quot;); String pwd = req.getParameter(&quot;pwd&quot;); // 2.封装对象 Users u = new Users(name, pwd); // 3. 调用业务层方法 Users users = ser.login(u); // 4. 判断是否登录成功 if(users!=null)&#123; System.out.println(&quot;登录成功&quot;); // 给请求中添加参数 req.setAttribute(&quot;message&quot;, &quot;成功了&quot;); // 跳转到主页面 req.getRequestDispatcher(&quot;main.jsp&quot;).forward(req, resp); &#125;else&#123; System.out.println(&quot;登录失败&quot;); // 给请求中添加参数 req.setAttribute(&quot;message&quot;, &quot;用户名密码有误~~~&quot;);; // 跳转到主页面 req.getRequestDispatcher(&quot;index.jsp&quot;).forward(req, resp); &#125; &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125;&#125; 可以看到servlet是继承于HttpServlet的。所以其中的方法都是HttpServlet写好的，我们只需要进行重构。 servlet doGet/doPost方法doGet顾名思义，doGet是用来从页面中拿取数据的，使用这个方法时，会拿到Rqeusst和Response两个函数，这两个函数的反法就能完成与JSP页面的交互，常用方法如下。12345678910//从页面输入框/选择框获取数据（用 name的值request.getParameter(&quot;name&quot;);//向页面传输一个数据,name的值，就是页面接受时所写的值(特殊语法)request.setAttribute(&quot;name&quot;, o);//jsp页面标记是这样的$&#123;name&#125;//跳转页面(转发) 地址栏不变，参数自动传递requset.getRequestDispatcher(&quot;index.jsp&quot;).forward(request,response);//跳转页面(重定向) 重新发送请求，地址栏改变。参数不传递response.sendRequser(&quot;index.jsp&quot;) doPost暂时没有用到，需要记住的就是再doGet之中呢那一句doGet(request,reponse)不能删除","categories":[{"name":"学习相关","slug":"学习相关","permalink":"http://yoursite.com/categories/学习相关/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"},{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/tags/JSP/"}]},{"title":"JSP学习日记01","slug":"JS学习日记01","date":"2019-04-25T12:47:26.000Z","updated":"2019-05-12T02:48:58.580Z","comments":true,"path":"2019/04/25/JS学习日记01/","link":"","permalink":"http://yoursite.com/2019/04/25/JS学习日记01/","excerpt":"开始学习JavaScript.","text":"开始学习JavaScript. 什么是JavaScriptJavaScript(一下简称JSP)是一种轻量级的编程语言,它可以被嵌入HTML页面之中.JSP通常用于网页与用户之间的交互,比如提交表单的时候,判断某些数值是否为空. 书写格式JSP代码必须放在script标签之中,script标签可以放在html的任何地方,一般建议放在head标签之中.像这样:1234567&lt;html&gt; &lt;head&gt; &lt;script&gt; document.write(&quot;这是 JavaScript&quot;) &lt;/script&gt; &lt;/head&gt;&lt;/html&gt; 执行顺序如果有多段jsp代码,回按照从上到下,顺序执行. 外部js文件如同CSS一样,jsp也可以被剥离出来,单独放在一个文件里.引用的时候使用:123&lt;html&gt; &lt;script src=&quot;./js/XXX.js&quot;&gt;&lt;script&gt;&lt;/html&gt; 注释和其他的东西注释方式与Java相同. 变量jsp之中,声明变量使用 var 关键字,jsp中变量的类型像py一样,不需要在声名的时候指定,它自己回随着被赋予的值而变化为五种基本数据类型之一. 关键字 意义 var 动态类型 undefined 声明但未赋值 Boolean 布尔 String 字符串 null 空对象/对象不存在 typeof 用于变量类型判断(这是一个方法).调试方法jsp没有专用的IDE.再加上它的特性,导致了他即使报错,在页面上也不一定能看到.这时,可以使用 alert 方法进行调试.1alert(1); alert 可以使浏览器弹出一个警告创口,以这个特性,我们就可以确定程序已经执行到了哪一步.同时,浏览器的F12控制台之中,可以看到报错的地点. 类型转换伪对象jsp有一个特征,就是即使是基本类型,也是伪对象,所以他们都有属性和方法.例如:12345&lt;script&gt; var a = &quot;hellow&quot;; document.write(&quot;变量a的类型是:&quot;+(typeof a)); document.write(&quot;变量a的长度是:&quot;+a.length);&lt;/script&gt; 类型转换不论是Number,Boolean,还是String都有一个toString方法. 转字符串String(),toString()都会返回字符串.区别在于对null的处理String()会返回字符串”null”.toString()则会报错,无法执行 数字转字符串Number.toString(x),可以给定进制X; 转换为数字parseInt(E),方法,可以将变量转换为数字.如果是一个同时拥有字符与数字的变量,它只会保留第一个数字.也就是说”1a2b3c”会变为”1”.但是如果以非数字开头,会返回NaNNumber(),方法,也可以转换,但是当转换的内容包含非数字的时候,会返回NaN 转换为布尔值Boolean(),方法,可以转换为布尔值. 当转换字符串时: 非空为true 当转换数字时: 非0为true 当转换对象时: 非null为true函数不多说,看代码:123function hanshu(x)&#123;&#125; 函数最常用的调用方式,是按钮调用,像这样:1&lt;button onclick=&quot;hanshu(1)&quot;&gt;按我&lt;/button&gt; 作用域作用域仅限于一个函数,超出函数就看不到了(可以声名全局变量,取决于你把它放哪). 运算符算数运算符 / % 加减乘除 取余– ** 自增自减= += -= -= /= %= 赋值运算符 经常会使数字运算变成字符串拼接.所以最好提前对被运算数据进行parseInt()转换为数字.逻辑运算符== != &gt; &gt;= &lt; &lt;= 基本=== !== 绝对等/不等看代码:123var x = 1;var y = &quot;1&quot;;var z = x===y; z最后的值是否,因为数据类型不同?: 三目运算符12var x = 9;var y = x&lt;10? &quot;小于&quot;:&quot;大于&quot;; 条件语句同JAVA 循环语句同JAVA 错误处理同JAVA(try catch)","categories":[{"name":"学习相关","slug":"学习相关","permalink":"http://yoursite.com/categories/学习相关/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JAVA常用类","slug":"JAVA常用类","date":"2019-04-14T10:44:44.000Z","updated":"2019-04-14T13:19:29.179Z","comments":true,"path":"2019/04/14/JAVA常用类/","link":"","permalink":"http://yoursite.com/2019/04/14/JAVA常用类/","excerpt":"这篇博客可能会长期更改并且更新，内容为JAVA常用类。","text":"这篇博客可能会长期更改并且更新，内容为JAVA常用类。 如果对哪个类的用法不清楚或者不知道是干嘛的，可以直接按着Ctrl然后点那个类，直接去看源文件。 StringString 是一个非常常用的数据类型。String类型中的常用方法如下： .lengh() 获取数组的长度，返回值为int。 .charAt(int) 根据下标查找字符。12String name = &quot;HeilantG&quot;;name.charAt(2); charAt会返回所给下标的字符，也就是说上面的代码会返回第三位i(第一位是0)。 .indexOf(all) 根据字符查找下标(从左向右找到该字符第一次出现的下标)。用法和charAt()相同。 .lastindexOf(all) 根据字符查找下标，不过是从右向左找。 .replace(String oldStr , String new Str) 字符替换。然后返回一个String类型的数据(并不是改变原数据)。需要注意的是，replace并不会改变原来的String数据。 .split(String str) 使用制定的字符，分割字符串，得到字符串数组。先看代码:12String name = &quot;aaa*bbb*ccc&quot;;String [] out= name.split(&quot;\\\\*&quot;); 可以看到这里需要使用*来分割数组。可是它又是特殊字符，这时就必须使用转义后再分割，分割后的数字中不会有分割字符，也就说out[0]中的字符为aaa，out[1]中字符为bbb。 .concat(String str) 字符串拼接。返回一个String类型。在拼接过程中，( ) 内的数组会被放在前面。 .contains(String str) 字符串是否包含指定字符，返回Boolean类型。 .equals(“”,String str) 比较字符串是否相等，返回Boolean类型。 .subString(int beginIndex,int endIndex) 从制定下标开始接取到指定位置，如果不写结束位置，会截取到结束。 .toLowerCase() .toUpperCase() 转换大小写。StringBuffer和StringBuilder当字符串需要被修改(增改插)时，一般的String类已经不能满足要求，这时就需要使用StringBuffer和StringBuilder类，他们和String不同的是，可以被多次修改，且不产生新的对象(直接修改，而不是返回值)。多数情况下使用StringBuilder，但是在要求安全时，使用StringBuffer。下面几个时他们拥有的新方法。 .append(String str) 将制定的字符串追加到此字符序列。 .reverse() 反转该字符串。 .delete(int start,int end) 移除此序列的子字符串中的字符。 .insert(int set,String str) 插入字符串，插入位置由Int指示。 .replace(int start,int end ,String str) 使用String中的字符替换由start、end提供下标所指定位置的字符。Math .abs() 绝对值 .round() 四舍五入 .ceil() 向上取整 .floor() 向下取整 .random() 随机数RandomRandom会创建一个随机数生成器，在创建时我们可以给他制定一个种子，总而达到虽然是随机，但是每次随机值都为固定。不多说，上代码：123Random r1 = new Random(2);int i = r1.nextInt(10);System.out.println(i); 第一行给予了种子 2 ，之后r1.nextInt(10),就是给与随机数区间。可以看到，不论随机几遍，随机出的数字都是固定的.","categories":[{"name":"学习相关","slug":"学习相关","permalink":"http://yoursite.com/categories/学习相关/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"JAVA学习日记07","slug":"JAVA学习日记07","date":"2019-04-10T11:32:47.000Z","updated":"2019-04-14T10:46:34.782Z","comments":true,"path":"2019/04/10/JAVA学习日记07/","link":"","permalink":"http://yoursite.com/2019/04/10/JAVA学习日记07/","excerpt":"摸了好多天鱼，继续学习","text":"摸了好多天鱼，继续学习 Java 流(Stream)、文件(File)和IO Java.io 包几乎包括了所有操作输入、输出所需要的类。所有这些流类代表了输入源和输出目标。 Java.io 包中的流支持很多格式，比如：基本类型、对象、本地化字符集等。 一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。读取控制台输入Java的控制台输入由System.in完成。为了获得一个字符流，可以把System.in包装在一个BufferedReader对象中来创建一个字符流。上代码：1234BufferedReader bf = new BufferedReader (new InputStreamReader(System.in)); 从控制台读取多字符输入从BufferedReader对象读取一个字符要使用read()方法。下面的程序使用了read()方法从控制台不断获取字符知道用户输入”q”。1234567891011public static void main(String args[]) throws IOException &#123; char c; // 使用 System.in 创建 BufferedReader BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); System.out.println(&quot;输入字符, 按下 &apos;q&apos; 键退出。&quot;); // 读取字符 do &#123; c = (char) br.read(); System.out.println(c); &#125; while (c != &apos;q&apos;); &#125; 从控制台读取字符串从标准输入读取一个字符串需要使用BufferedReader的readLine()方法。下面的程序读取显示字符，直到你输入了单词”end”。12345678public static void main(String args[]) throws IOException &#123; String str; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); do &#123; str = bf.readLine(); &#125;while (!str.equals(&quot;end&quot;));&#125; JDK5以后的版本可以使用Scanner类来获取控制台的输入JDK5以后的版本可以使用Scanner类来获取控制台的输入JDK5以后的版本可以使用Scanner类来获取控制台的输入淦 控制台输出请使用print()和println()有这么个东西：12int b;System.out.write(v); 用法和那两个一样，然鹅请使用那两个。 读写文件首先，这里应该有张图，然后，我懒得给服务器传了。最后，你可以看这。菜鸟教程如上所属，一个流被定义为一个数据列，输入流用于从源读取数据，输出流用于向目标写数据。重点讨论FileInputStream和FileOutpStream FileInputStream该流用于从文件读取数据，他的对象使用new来创建。可以这样：1InputStream f =new FileInputStream(&quot;E:/hello.txt&quot;); 也可以这样：12File f = new File(&quot;\\&quot;E:/hello.txt\\&quot;&quot;)InputStream out =new FileInputStream(f); 创建InputStre对象，就可以使用下面的方法","categories":[{"name":"学习相关","slug":"学习相关","permalink":"http://yoursite.com/categories/学习相关/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"JAVA学习日记06","slug":"JAVA学习日记06","date":"2019-03-31T11:54:36.000Z","updated":"2019-04-14T10:46:17.462Z","comments":true,"path":"2019/03/31/JAVA学习日记06/","link":"","permalink":"http://yoursite.com/2019/03/31/JAVA学习日记06/","excerpt":"之前几天都在摸鱼，玩Apex、彩六。想了想还是继续学习更有意义。游戏真好玩本篇主要内容：继承于多态","text":"之前几天都在摸鱼，玩Apex、彩六。想了想还是继续学习更有意义。游戏真好玩本篇主要内容：继承于多态 接口初步理解，可以认为接口是一个特殊的抽象类，当类中的方法、常量都是抽象的，那么改类就可以通过接口的形式表示。定义格式： 接口中常见定义：常量(public static final)、抽象方法(public abstract)。接口中的成员(变量和方法)都是public的。例子：1234interface Inter&#123; int NUM = 3; void show();&#125;; 如上，即使不写public，interface也会进行默认补全，但是一般建议写全。1234interface Inter&#123; public static final int NUM = 3; public abstract void show(); 接口是不可能创建对象的，因为其中的方法都是抽象的，而抽象方法就需要子类来实现(重写)，接口可以被多类实现，也是java对多继承不支持的取代方式，java不支持多继承，但支持多实现。12345678910111213141516171819202122interface Inter&#123; public static final int NUM = 3; public abstract void show( );&#125;interface Inrer1&#123; void out();&#125;class test implements Inter,Inrer1&#123; @Override public void show() &#123; System.out.println(&quot;hi&quot;); &#125;; @Override public void out() &#123; &#125;&#125;public class learn&#123; public static void main(String[] args) &#123; test a = new test(); a.show(); &#125;&#125; java不支持多继承是因为父类的方法会重复，多继承会导致子类调用时出现冲突。 在实现多接口中，接口没有方法主体，类在实现时，可以重写方法体，继式接口中出现多个相同方法，都会被类所重写，从而变为一个方法12345678910111213141516171819interface Inter&#123; public abstract void show( );&#125;interface Inrer1&#123; void show();&#125;class test implements Inter,Inrer1&#123; @Override public void show() &#123; System.out.println(&quot;hi&quot;); &#125;;&#125;public class learn&#123; public static void main(String[] args) &#123; test a = new test(); a.show(); &#125;&#125; 注：多个接口的同名方法返回值必须一致。 类与接口互相之间的关系类与类之间：继承类与接口之间：实现*接口与接口之间：继承123456interface Inter&#123; public abstract void show();&#125;interface Inrer1 extends Inter&#123; void show();&#125; 接口与接口之间可以多继承(因为接口不存在方法体，方法之间不会冲突). 接口的特点 接口是对外暴露的规则(public) 接口是程序的功能拓展 接口可以用来多实现 类与接口之间是实现关系，而类可以在继承一个类的同时，实现多个接口 接口与接口之间可以有继承关系多态多态：可以理解为事物存在的多种体现形态人：男人、女人动物：，猫、狗猫 x = new 猫();动物 x = new 猫();拓展性123456789101112131415161718192021222324252627282930313233abstract class Animal&#123; abstract void eat();&#125;class Cat extends Animal&#123; @Override void eat() &#123; System.out.println(&quot;吃鱼&quot;); &#125; public void catchMouse()&#123; System.out.println(&quot;抓老鼠&quot;); &#125;&#125;class Dog extends Animal&#123; @Override void eat() &#123; System.out.println(&quot;啃骨头&quot;); &#125; public void kanJia()&#123; System.out.println(&quot;看家&quot;); &#125;&#125;public class learn &#123; public static void main(String[] args) &#123; function(new Cat()); function(new Dog()); &#125; public static void function(Animal a) &#123; a.eat(); &#125;&#125; 好处：大大提高了程序的拓展性前提：必须是类与类之间有关系(继承或实现)；通常还要一个前提，存在覆盖。弊端：虽然提高了拓展性，但是只能使用父类的引用和访问父类的成员(Animal的eat()方法)。 转型12345678910111213141516171819202122abstract class Animal&#123; int out = 3; abstract void eat();&#125;class Cat extends Animal&#123; @Override void eat() &#123; System.out.println(&quot;吃鱼&quot;); &#125; public void catchMouse()&#123; System.out.println(&quot;抓老鼠&quot;); &#125;&#125;public class learn &#123; public static void main(String[] args) &#123; Animal a = new Cat(); ((Cat) a).catchMouse(); System.out.println(a.out); &#125;&#125; 多态：Animal a = new Cat();存在引用数据类型的类型提升，即向上转型。这样的a，可以同时使用它的父类与他自己的所有方法和常量。在调用自己时，要强制将父类的引用，转为子类类型。多态自始至终都是子类对象在变化。123456789101112131415161718192021222324252627282930313233343536373839abstract class Animal&#123; abstract void eat();&#125;class Cat extends Animal&#123; @Override void eat() &#123; System.out.println(&quot;吃鱼&quot;); &#125; public void catchMouse()&#123; System.out.println(&quot;抓老鼠&quot;); &#125;&#125;class Dog extends Animal&#123; @Override void eat() &#123; System.out.println(&quot;啃骨头&quot;); &#125; public void kanJia()&#123; System.out.println(&quot;看家&quot;); &#125;&#125;public class learn &#123; public static void main(String[] args) &#123; function(new Dog()); &#125; public static void function(Animal a) &#123; a.eat(); if (a instanceof Cat) &#123; Cat c = (Cat) a; c.catchMouse(); &#125; else if (a instanceof Dog) &#123; Dog d = (Dog) a; d.kanJia(); &#125; &#125;&#125; a instancefo Cat判断a是否属于Cat这个引用类型。","categories":[{"name":"学习相关","slug":"学习相关","permalink":"http://yoursite.com/categories/学习相关/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"JDBC学习日记02","slug":"JDBC学习日记02","date":"2019-03-27T12:20:13.000Z","updated":"2019-04-09T06:50:53.102Z","comments":true,"path":"2019/03/27/JDBC学习日记02/","link":"","permalink":"http://yoursite.com/2019/03/27/JDBC学习日记02/","excerpt":"为什么这是第二篇呢？因为第一篇是JAVA学习日记05。","text":"为什么这是第二篇呢？因为第一篇是JAVA学习日记05。之前说了基础的链接，今天写一下一些查询的语法和其他东西。 StatementStatement：阐明，陈述。在使用Statement语法前，需要先使用Connection对象的creaeStatement()方法创建一个Statement对象。看代码：12Connection con = DriverManager.getConnection(url,name,pwd);Statement st = con.createStatement(); Statement就是支撑SQL语句运行的关键。他有三个方法可以执行。 boolean execute (String SQL)第一个方法，excute:执行。他的返回值为Boolean，如果可以检索到结果集对象，则返回 true ；否则返回 false。可用于执行创建数据库、创建表的SQL语句。1boolean out = st.execute(&quot;create table stu(stu int)&quot;); 请注意，对他取返回值目前并没有意义。 int executeUpdate (String SQL)第二个方法，executeUpdate:执行更新。返回值为int，简单明了的看出来他可以控制增删改(INSERT,UPDATE,DELETE)。1int out= st.executeUpdate(&quot;insert stu(stu) values(1),(2)&quot;); 所返回的int数据为语句所更改的行数。 ResultSet executeQuery(String SQL)第三个方法，executeQuery:执行查询，返回值为ResultSet(这是JDBC中的一个特殊数据类型),也就是结果集，控制SELECTT。想要获得查询结果，需要使用一个循环，先看代码：123456ResultSet out=st.executeQuery(&quot;select * from stu&quot;);int x;while (out.next())&#123; x=out.getInt(&quot;stu&quot;); System.out.println(x);&#125; 可以看到，executeQuery返回了一个ResultSet类型的结果集out。out.next()方法用来判断out的下一行还有没数据，而out.get方法则是得到数据，括号内的值可以是那一列的列名字，或者数字(表示第几列)。","categories":[{"name":"学习相关","slug":"学习相关","permalink":"http://yoursite.com/categories/学习相关/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"JDBC","slug":"JDBC","permalink":"http://yoursite.com/tags/JDBC/"}]},{"title":"JAVA学习日记05","slug":"JAVA学习日记05","date":"2019-03-26T09:28:40.000Z","updated":"2019-04-14T10:46:30.036Z","comments":true,"path":"2019/03/26/JAVA学习日记05/","link":"","permalink":"http://yoursite.com/2019/03/26/JAVA学习日记05/","excerpt":"今天本来以为上课会继续讲面向对象，然后我就可以继续自己看了，然鹅老师讲了JDBC。","text":"今天本来以为上课会继续讲面向对象，然后我就可以继续自己看了，然鹅老师讲了JDBC。 什么是JDBC？JDBC，简单来说，JDBC就是一个允许Java使用SQL的包。SQLserver包的的下载地址是：点我 JDBC的使用连接数据库想要连接数据库，首先要保证数据库的TCP/IP协议是打开着的。上代码：12345678910111213import java.sql.*;class JDBC&#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; String driver =&quot;com.microsoft.sqlserver.jdbc.SQLServerDriver&quot;; String url = &quot;jdbc:sqlserver://localhost;databast=shangpin&quot;; String name = &quot;sa&quot;; String pwd = &quot;123456&quot;; Class.forName(driver); Connection con = DriverManager.getConnection(url,name,pwd); Statement st = con.createStatement(); &#125;&#125; 首先自然要导入java.sql.*这个包(当然现在都是自动导入),然后可以看到声明了四个String类型的变量，同时给他们赋予了四个值。变量名随心情写 driver：这里面是固定写法，如果你使用的数据库不是SQLserver那么会不一样，里面的内容可以在空白处打个 com. 然后一路自动补全后剪切进去。 url：这里面的是服务器的地址，以及你想访问的数据库名称。 name：数据库登陆用户名。*pwd：数据库密码。 123Class.forName(driver);Connection con = DriverManager.getConnection(url,name,pwd);Statement st = con.createStatement(); class.forName(driver) 是调用驱动，写上就完了。 第二句后半段：直译过来是驱动程序管理器.获取连接,也就是获取一个可以直接与数据库交互的key。(可以试着输出一下)。而Connection con也就是将这个key保存了起来。 JDBC中的SQL語句是使用Connection對象的createStatement方法建立的。–某个地方的解释。 也就是说，sql所有的语句都要利用Statement方法(等于说它是一个抽象类)来执行。 增删改插语句的执行。先看代码：123String update = &quot; use shangpin INSERT into sp (name,price,text ) VALUES(苹果&apos;,10,&apos;吃&apos;)&quot;;String delete = &quot;use shangpin delete sp where name=&apos;苹果&apos;&quot;;st.executeUpdate(update); 我们可以将这段代码这样理解，我们生成了两个String类型的变量，然后使用st.executeUpdate();将String内的内容作为sql文件发送给数据库，再获得返回值。String类的语句就是SQL语句。 查询老样子：1234567String select = &quot;use shangpin select * from sp&quot;;ResultSet rs =st.executeQuery(select);while (rs.next())&#123; int id = rs.getInt(1); String name = rs.getString(&quot;name&quot;); System.out.println(id+name);&#125; 使用查询时，要使用st.executeQuery();，它会返回查询的值，然后定义一个ResultSet(结果集)用来存储他。查询完毕后肯定是要输出了。这段代码中的while循环就是用来确定输出的，rs.next()是用来判断返回集(rs)的下一行后没有数据，如果有，那就继续执行。int id = rs.getInt(1);这个语句用来将rs这一行的Int数据赋给id,括号内的数字表示取的是表中第几列。这是两种不同的写法，都可以使用rs.getString(“name”)；则是将这一行列名为”name”的值赋给name。切记，不要xjb乱赋数据类型。 实例12345678910111213141516171819202122232425262728293031323334353637import java.sql.*;import java.util.Scanner;class Sc&#123; Scanner in = new Scanner(System.in); String input; public String getInput() &#123; return input; &#125; public void setInput(String input) &#123; this.input = input; &#125; Sc()&#123; input=in.next(); &#125;&#125;class JDBC&#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; String driver = &quot;com.microsoft.sqlserver.jdbc.SQLServerDriver&quot;; String url = &quot;jdbc:sqlserver://localhost;databast=shangpin&quot;; String uname = &quot;sa&quot;; String pwd = &quot;123456&quot;; Class.forName(driver); Connection con = DriverManager.getConnection(url,uname,pwd); Statement st = con.createStatement(); Sc seach = new Sc(); String sql = &quot;use shangpin select * from sp where name=&apos;&quot;+seach.getInput()+&quot;&apos;&quot;; ResultSet out = st.executeQuery(sql); int money = 0; String name ; while (out.next())&#123; money= out.getInt(&quot;price&quot;); name = out.getString(&quot;name&quot;); System.out.println(&quot;商品名&quot;+name+&quot;价格：&quot;+money); &#125; &#125;&#125;","categories":[{"name":"学习相关","slug":"学习相关","permalink":"http://yoursite.com/categories/学习相关/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"JDBC","slug":"JDBC","permalink":"http://yoursite.com/tags/JDBC/"}]},{"title":"JAVA学习日记04","slug":"JAVA学习日记04","date":"2019-03-25T14:59:44.000Z","updated":"2019-03-25T15:49:36.741Z","comments":true,"path":"2019/03/25/JAVA学习日记04/","link":"","permalink":"http://yoursite.com/2019/03/25/JAVA学习日记04/","excerpt":"我将抽象类单独拿出来写一篇日记，因为觉得很有用也很重要。","text":"我将抽象类单独拿出来写一篇日记，因为觉得很有用也很重要。 抽象类先看代码：12345678910class Man&#123; void speak()&#123; System.out.println(&quot;i am a Man&quot;); &#125;&#125;class Woman&#123; void speak()&#123; System.out.println(&quot;i am a Woman&quot;); &#125;&#125; 可以看到，在Man于Woman两个类中，都有一样的方法，所以需要抽取相同的功能。但是两者虽然都在说话，但是所说的内容却不一样。解决：可以进行向上抽取，只抽取功能定义，不抽取主题(即抽象类)。对于这样的方法，必须使用abstract进行修饰。抽象方法必须定义在抽象类中也就是说，上面的代码可以改写成：12345678910111213abstract class Human&#123; abstract void speak();&#125;class Man extends Human&#123; void speak()&#123; System.out.println(&quot;i am a human&quot;); &#125;&#125;class Woman extends Human&#123; void speak()&#123; System.out.println(&quot;i am a human&quot;); &#125;&#125; 定义了一个抽象类Human以及之中包含一个抽象方法speak，在这里确实看不出什么不同。稍安勿躁，请继续看下去。抽象类的特点： 抽象方法一定在抽象类中 抽象方法和抽象类被abstract修饰 抽象方法不可以用new创建对象，因为调用抽象方法没用意义(里面的抽象方法没用方法体) 抽象类中的抽象方法的使用方式是：被子类复写其所有抽象方法后，建立子类对象。(所有抽象方法都必须被复写)抽象类于一般类没有他太多不同。只是要注意该如何描述事物，只是这个事物中出现了一些不确定的东西，这些不确定的部分也是这个事物的功能，需要明确写出来，只是无法定义其主体。 抽象类比一般类多了抽象的方法。当然也可以没用抽象方法。 抽象类不会也不可以被实例化 抽象类完全可以不定义抽象方法，这样它就不会创建对象让我们用一个实例来搞清楚,需求：获取一段程序运行的时间原理：获取程序开始与结束的时间并相减，获取本机系统时间：System.currentTimeMillis()获取当前时间的毫秒值，返回的值是当前时间减去1970.01.01、00：00：00之间的时间差。好解决：12345678910111213141516class GetTime&#123; public void getTime()&#123; long start = System.currentTimeMillis(); for (int x = 0 ; x&lt;100 ; x++)&#123; System.out.println(x); &#125; long end = System.currentTimeMillis(); System.out.println(&quot;time:&quot;+(end-start)); &#125;&#125;public class learn&#123; public static void main(String[] args) &#123; GetTime gt = new GetTime(); gt.getTime(); &#125;&#125; 并没有多难的问题，那么现在新的问题来了：像获取另一段代码的运行时间。解决：直接子类复写掉getTime方法12345678910111213141516class SubTime extends GetTime&#123; public void getTime()&#123; long start = System.currentTimeMillis(); for (int x = 0 ; x&lt;400 ; x++)&#123; System.out.println(x); &#125; long end = System.currentTimeMillis(); System.out.println(&quot;time:&quot;+(end-start)); &#125;&#125;public class learn&#123; public static void main(String[] args) &#123; SubTime gt = new SubTime(); gt.getTime(); &#125;&#125; 但是这样代码重复性会爆炸。解决：将需要运行的代码提取出来形成一个新的方法，子类重复时，只需要复写提取出的代码。1234567891011121314151617181920class GetTime&#123; public void getTime()&#123; long start = System.currentTimeMillis(); runcode(); long end = System.currentTimeMillis(); System.out.println(&quot;time:&quot;+(end-start)); &#125; public void runcode()&#123; for (int x = 0 ; x&lt;100 ; x++)&#123; System.out.println(x); &#125; &#125;&#125;class SubTime extends GetTime&#123; public void runcode()&#123; for (int x = 0 ; x&lt;400 ; x++)&#123; System.out.println(x); &#125; &#125;&#125; 但是这样还是有些臃肿，在GetTime中等于说多谢了一次无用代码，而且提取出来的需要运行的代码并不确定。解决：将GetTime类写为抽象，并且getTime方法不可复写所以用final修饰，如下:12345678910111213141516171819202122abstract class GetTime&#123; public final void getTime()&#123; long start = System.currentTimeMillis(); runcode(); long end = System.currentTimeMillis(); System.out.println(&quot;time:&quot;+(end-start)); &#125; abstract public void runcode();&#125;class SubTime extends GetTime&#123; public void runcode()&#123; for (int x = 0 ; x&lt;400 ; x++)&#123; System.out.println(x); &#125; &#125;&#125;public class learn&#123; public static void main(String[] args) &#123; SubTime gt = new SubTime(); gt.getTime(); &#125;&#125; 这样不论换到了那个代码中，这个GetTime方法都可以很好的运行。 所感抽象类真的是一个神奇的东西，很强大而且高效，现在是晚上的11.46，今天的学习就到这里，明天的学习将从接口开始。","categories":[{"name":"学习相关","slug":"学习相关","permalink":"http://yoursite.com/categories/学习相关/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"JAVA学习日记03","slug":"JAVA学习日记03","date":"2019-03-25T02:56:24.000Z","updated":"2019-03-25T15:12:14.484Z","comments":true,"path":"2019/03/25/JAVA学习日记03/","link":"","permalink":"http://yoursite.com/2019/03/25/JAVA学习日记03/","excerpt":"这是在课堂上写的笔记（虽然是自学），记录一些特性","text":"这是在课堂上写的笔记（虽然是自学），记录一些特性 继承中的一些问题static 关键字static(标准的)关键字在学习java的第一天我就开始使用了，然鹅一直没有搞懂它的意义，这两天的学习后，算是有了一个初步的见解。官话：被static修饰的类或变量会在加载时被加载（等于把它从对象所属的内存中单独拿出来，整体放在一个新的内存中），从而节省内存占用。上代码：12345678910111213class Human &#123; static String name;&#125;public class learn &#123; public static void main(String[] args) &#123; human hm = new human(); hm.name=&quot;ab&quot;; human hm1=new human(); hm1.name=&quot;cd&quot;; System.out.println(hm.name); System.out.println(hm1.name); &#125;&#125; 围绕代码第二行name变量，我将讨论static在类中使用时产生的一些特性。上面的代码创建了两个继承于human类的对象hm、hm1。同时对各自的name进行了赋值，这样输出后会输出各自的名字，在这种情况下，static关键字即使去除，也不会影响整体。 再看这个：123456789101112class Human &#123; static String name;&#125;public class learn &#123; public static void main(String[] args) &#123; human hm = new human(); hm.name=&quot;ac&quot;; human hm1=new human(); System.out.println(hm.name); System.out.println(hm1.name); &#125;&#125; 在这里，去掉了对hm1.name的赋值。但是，在程序执行后输出的hm1.name却等于hm.name，产生这种情况的原因就是上面说到的，name变量被从每一个对象中单独拿了出来，被整体（这个概念是有误的，因为使用正确的话，并不会产生多个名字叫name的变量，但是可以先这么理解）拿了出来，只留给了每个对象一个内存地址。 这时有一个问题，static到底有什么用？既然我加不加这个修饰，对程序的结果好像并不会产生肉眼可见的影响。让我们继续上代码：1懒得复制了，请把上面那个human类中name前面的static删了 这时，我们发现hm1.name输出值为null,这个时候，hm.name与hm1.name都安分的被安置在二者各自占用的内存中，互相不会产生影响。 static 使用建议（规范） 使用static后，这个变量生命等同于这个方法，避免了每一次声明新对象时都要重新创建变量。 区分被修饰的变量是多个对象共用同一个数值还是每个对象都有自己都有自己独立的变量。 static所拿出来的变量在内存中是被分类放置还是说仅仅是拿出来？ 构造函数与标准(static)函数在对象中，友两种特殊函数，第一种为构造函数,另一种就是static函数。像这样：123456789101112131415class Human &#123; static String name; Human()&#123; System.out.println(&quot;嘿嘿嘿&quot;); &#125; static &#123; System.out.println(&quot;呼呼呼&quot;); &#125;&#125;public class learn &#123; public static void main(String[] args) &#123; Human hm = new Human(); Human hm1=new Human(); &#125;&#125; 在第一次创建继承于Human类的对象时(hm)，构造函数于static函数都会运行，但是static优先于构造函数。但是，之后再次创建基于Human类的对象时，仅会运行static。 extends 继承先看代码：1234567891011121314151617181920class Worker&#123; private String name; private int age; void work()&#123; System.out.println(&quot;我唔想返工啊&quot;); &#125;&#125;class Student&#123; private String name; private int age; void learn()&#123; System.out.println(&quot;我唔想返校啊&quot;); &#125;&#125;public class learn &#123; public static void main(String[] args) &#123; Student stu = new Student(); Worker wor = new Worker(); &#125;&#125; 在这里可以看到在worker类于student类之中都有重复的两个变量name于age，这样如果代码写长后会严重影响效率（大量重复操作）,所以可以创建一个父类，父类中含有name与age。like this：123456789101112131415161718192021222324252627282930class Human&#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;class Worker extends Human&#123; void work()&#123; System.out.println(&quot;我唔想返工啊&quot;); &#125;&#125;class Student extends Human&#123; void learn()&#123; System.out.println(&quot;我唔想返校啊&quot;); &#125;&#125;public class learn &#123; public static void main(String[] args) &#123; Student stu = new Student(); stu.setName(&quot;滑稽&quot;); Worker wor = new Worker(); wor.setName(&quot;大滑稽&quot;); &#125;&#125; 在这里，可以看到创建了一个名为Human的类，同时让Student与Worker继承Human，这样二者就都拥有了name与age，同时也拥有了get、set方法。(我并没有写age的get)。 父子类构造函数特点类与类之间的关系-聚集(组合)关系事物之间不一定都是继承关系，也存在聚集关系，就说是谁里面有谁。聚合：班级与班级中的学生组合：事物间的联系比聚合关系更高，比如：心脏和人、手和人。 父子类中变量的特点先看代码：123456789101112131415class father&#123; int num = 1;&#125;class son extends father&#123; int num = 2; void show()&#123; System.out.println(super.num); &#125;&#125;public class learn&#123; public static void main(String[] args) &#123; son test = new son(); test.show(); &#125;&#125; 可以看到，在父类father与子类son中，都存在一个名字为num的变量。在show方法中,输出了super.num,最终的输出值为1，这并不难理解。但是我们发现，在程序的运行中，出现了两个名为num的变量，但是因为存在于两个不同的类中，所以并不会混乱(之间经常用)，使用super与this关键字即可控制输出。 父子类中变量的特点-覆盖(重写)先看代码：1234567891011121314151617class father&#123; void show()&#123; System.out.println(&quot;呼呼呼&quot;); &#125;&#125;class son extends father&#123; void show()&#123; super.show(); System.out.println(&quot;嘿嘿嘿&quot;); &#125;&#125;public class learn&#123; public static void main(String[] args) &#123; son test = new son(); test.show(); &#125;&#125; 如果子父类中方法一致，那么在最终执行时，只会执行子类中的语句(重写)(如果子类中没用show方法，那么test.show会执行father中的show)。如果实在像调用父类中的同名方法，那么就在子类方法中写super.方法名。利用这个特性，可以增强程序拓展性。注意：子类覆盖父类，必须保证子类权限大于父类，且父类不能为private(如果是privatt,子类根本就不能继承这个方法)。 父子类构造函数的特点-子类实例化过程父子类构造函数不能进行覆盖，因为覆盖时必须函数名和返回值都一模一样，但是构造函数的名字必须与类名一致。子类的构造函数又一句隐藏的super();像这样：1234567891011class father&#123; father()&#123; System.out.println(&quot;呼呼呼&quot;); &#125;&#125;class son extends father&#123; son()&#123; // super(); System.out.println(&quot;呵呵呵&quot;); &#125;&#125; 在子类对象初始化时，父类构造函数也会运行，且这一句隐藏的super();位于子类构造函数的第一行(最优先执行);当父类的构造函数中含有参数时，子类就无法自动调用父类的构造函数了，因为super();并没有给予任何值。例如：12345678910class father&#123; father(int a )&#123; &#125;&#125;class son extends father&#123; son()&#123; //super(); 默认生成的super此时肯定无效 super(1); &#125;&#125; 这时，就有这样一种写法：1234567891011121314151617181920class father&#123; father()&#123; System.out.println(&quot;嘿嘿嘿&quot;); &#125; father(int a )&#123; &#125;&#125;class son extends father&#123; son()&#123; super(1); &#125;&#125;class son1 extends father&#123;&#125;public class learn&#123; public static void main(String[] args) &#123; son test = new son(); son1 test1 = new son1(); &#125;&#125; 在father类种写入几种构造函数，然后再继承中更改数值，从而调用不同的构造函数。总结：父类以及定义过的方法属性，子类可以直接用super拿到。 final 不继承总是继承也不是好的，有的时候，我们不需要某个数据被继承，仅仅需要它保持原样。这时,就可以用到final关键字。像这样：12345678910111213class father&#123; final int a =1; father()&#123; System.out.println(&quot;嘿嘿嘿&quot;); &#125;&#125;class son extends father&#123; int a= super.a; son()&#123; System.out.println(super.a); &#125;&#125; 父类中的变量a被final进行了修饰，此时，在子类中是无法修改它的值的，仅仅能调用它。 get、set自动生成IDEA可以(应该所以编译器都可以)自动生成get与set。","categories":[{"name":"学习相关","slug":"学习相关","permalink":"http://yoursite.com/categories/学习相关/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"JAVA学习日记02","slug":"JAVA学习日记02","date":"2019-03-19T12:49:49.000Z","updated":"2019-03-25T03:58:50.509Z","comments":true,"path":"2019/03/19/JAVA学习日记02/","link":"","permalink":"http://yoursite.com/2019/03/19/JAVA学习日记02/","excerpt":"今天在写作业的时候,遇到了一个问题：如何在类中执行一些语句，以及生成类时队类进行赋值等操作。然后想到了上一次笔记中的实例,之后去研究了一下，看到博客园的一篇博客，以下是针对Java构造函数和类中执行语句的笔记。","text":"今天在写作业的时候,遇到了一个问题：如何在类中执行一些语句，以及生成类时队类进行赋值等操作。然后想到了上一次笔记中的实例,之后去研究了一下，看到博客园的一篇博客，以下是针对Java构造函数和类中执行语句的笔记。 Java构造函数(方法)解释Java构造函数，也称构造方法，是Java中一种特殊的函数，函数名与Clas名相同，无返回值。一般用于初始化成员属性和方法，在new产生新对象的同时，对对象进行初始化(对对象内变量赋值)。 注意事项 构造函数是对象一建立(new)就执行，对对象进行初始化，或执行方法中所写的语句。 一般函数必须用”对象名.方法名”的方式调用才能执行。 当一个对象建立后，构造函数会在初始化时运行，不允许调用而一般函数可以被对象调用多次 构造函数书写规定/特点 函数名与类名相同。 不需要定义返回值类型。 不可以写reurn语句。(因为没有返回值) 构造函数为public类型。示例1234567891011121314151617public class blogtest &#123; public static void main(String[] args)&#123; Person z=new Person(&quot;heilantg&quot;,17); //这就是在创建对象时初始化 z.show(); &#125;&#125;class Person&#123; private String name; private int age; public Person(String n,int m)&#123; //这就是构造函数，它获取了main函数中的值，将其赋予了name和age name=n; age=m; &#125; public void show()&#123; //输出name与age System.out.println(name+&quot;\\n&quot;+age); &#125;&#125; 可以看到，在初始化赋值的过程中，并不能将所接收的函数直接写在构造函数处，而是使用了一个二级的跳转，先将其赋值给n、m再将n、m的值赋予name与age。 对象调用其他方法依旧是上面的示例，可以看到在程序的第四行：1z.show(); 以及第14-16行：123 public void show()&#123; System.out.println(name+&quot;\\n&quot;+age);&#125; 可以看到，对象z使用了语法”对象名.方法名”，从而执行了方法show中的输出语句。 对象的赋值示例的第三行的初始化也可以写成这样1Person z=new Person(sc.next(),sc.nextInt()); 也就是说，只要这个值符合对象父类所接收的类型，就可以被接收。 对象的再赋值如果在构造函数执行完毕后，需要重新修改对象的某个值时,推荐写两个新方法get、set123456public void setName(String x)&#123; //set方法，用于再次给name赋值 name=x;&#125;public String getName()&#123; //get方法，用于获取name的赋值return name;&#125; 例如，创建一个新对象a,name=”Grover”,现在要将a.name(这个语法是错误的，因为name为private)赋予z.name。那么就可以这样写。1z.setName(a.getName()); 这个语句会调用getName与setName方法，从而使z.name发生改变。","categories":[{"name":"学习相关","slug":"学习相关","permalink":"http://yoursite.com/categories/学习相关/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"JAVA学习日记01","slug":"JAVA学习日记01","date":"2019-03-17T13:25:54.000Z","updated":"2019-03-17T14:41:05.990Z","comments":true,"path":"2019/03/17/JAVA学习日记01/","link":"","permalink":"http://yoursite.com/2019/03/17/JAVA学习日记01/","excerpt":"从今天起关于SQL的学习就高一段路了，又开始了Java的学习，在这之后我觉得我们才可以被称之为Java程序员了，真正接触到Java的一些特性。今天的日记是自学得出的，之后可能会进行修改。","text":"从今天起关于SQL的学习就高一段路了，又开始了Java的学习，在这之后我觉得我们才可以被称之为Java程序员了，真正接触到Java的一些特性。今天的日记是自学得出的，之后可能会进行修改。 Java继承参阅网页 什么是继承继承是Java面向对象技术的基础，他允许创建分等级、层次的类。继承就是子类继承父亲的特征与行为，使得子类对象(方法)具有父类的方法与特征。例如：人类、兔子，树，蘑菇。这四种生物的共同父类为碳基生物，人类与兔子的父类为动物，而树和蘑菇的父类为植物，而动物与植物的父类也是碳基生物，所以继承有多重性，可以理解为父类与爷类。简单来说，继承就是几个子类同时使用一个父类的属性(参数)。 为什么要使用继承继承可以简单高效的缩短代码长度，方便后续的修改(只需要更改父类的，子类就跟着会改变)。 实例12345678910111213141516171819202122232425class human&#123; public String name; human()&#123; System.out.println(&quot;i am not a bot&quot;); &#125; human(int n)&#123; System.out.println(&quot;i am a bot&quot;); &#125; human(String a)&#123; System.out.println(&quot;i don&apos;t know&quot;); &#125;&#125;// human为父类public class blogtest&#123; public static void main(String args[])&#123; human hm1 = new human(); human hm2 = new human(1); human hm3 = new human(&quot;s&quot;); hm1.name=&quot;cat&quot;; hm2.name=&quot;dot&quot;; System.out.println(hm1.name); System.out.println(hm2.name); &#125;&#125; 这段代码的执行结果为12345i am not a boti am a boti don&apos;t knowcatdot 可以看到对human进行赋值？后产生了不同的结果。这里的方法名虽然一样，但返回值设定不同，在执行时，会根据返回值来进行判断。同时可以看到hm1与hm2的name被赋予了不同的两个值 extends与implement在Java中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类。而，implements可以变相的使一个类同时继承多个父类。 菜鸟教程的示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class SuperClass &#123; private int n; SuperClass()&#123; System.out.println(&quot;SuperClass()&quot;); &#125; SuperClass(int n) &#123; System.out.println(&quot;SuperClass(int n)&quot;); this.n = n; &#125;&#125;// SubClass 类继承class SubClass extends SuperClass&#123; private int n; SubClass()&#123; // 自动调用父类的无参数构造器 System.out.println(&quot;SubClass&quot;); &#125; public SubClass(int n)&#123; super(300); // 调用父类中带有参数的构造器 System.out.println(&quot;SubClass(int n):&quot;+n); this.n = n; &#125;&#125;// SubClas2 类继承class SubClass2 extends SuperClass&#123; private int n; SubClass2()&#123; super(300); // 调用父类中带有参数的构造器 System.out.println(&quot;SubClass2&quot;); &#125; public SubClass2(int n)&#123; // 自动调用父类的无参数构造器 System.out.println(&quot;SubClass2(int n):&quot;+n); this.n = n; &#125;&#125;public class TestSuperSub&#123; public static void main (String args[])&#123; System.out.println(&quot;------SubClass 类继承------&quot;); SubClass sc1 = new SubClass(); SubClass sc2 = new SubClass(100); System.out.println(&quot;------SubClass2 类继承------&quot;); SubClass2 sc3 = new SubClass2(); SubClass2 sc4 = new SubClass2(200); &#125;&#125; 输出结果为：12345678910------SubClass 类继承------SuperClass()SubClassSuperClass(int n)SubClass(int n):100------SubClass2 类继承------SuperClass(int n)SubClass2SuperClass()SubClass2(int n):200 可以发现，一个语句同时调用了生命是规定的类和那个类的父类，产生了两个输出结果。 所感及杂七杂八这可以说是Java的关键之处,必须要把它搞透彻，多去想想他的意义。今天她穿上了汉服，真的好看，期待一起出去玩。努力让自己配得上她。","categories":[{"name":"学习相关","slug":"学习相关","permalink":"http://yoursite.com/categories/学习相关/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"SQL学习日记02","slug":"SQL学习日记02","date":"2019-03-04T11:10:38.000Z","updated":"2019-03-05T07:00:51.441Z","comments":true,"path":"2019/03/04/SQL学习日记02/","link":"","permalink":"http://yoursite.com/2019/03/04/SQL学习日记02/","excerpt":"这是SQL第二周第一节课的笔记，我们的老师这周请了一周假，今天代课的老师讲的好快啊，但是基本听懂了，而且要夸奖一下这位老师的代码规范程度。","text":"这是SQL第二周第一节课的笔记，我们的老师这周请了一周假，今天代课的老师讲的好快啊，但是基本听懂了，而且要夸奖一下这位老师的代码规范程度。 语法别名用于对库进行重命名（只在这一个语句中生效）确实方便不少,如果对列名进行别名定义则会改变查找出的列名称。语法：1select s.score 学号，students as stu 去重用于去除列表中重复的项目，目前还没什么用，当去重时，select后只能用一个列名。语法：12select distinctt s.stuIDfrom score 部分显示只显示搜索出的一部分（常用于排名)语法：12345--top n * 表示显示多少行select top 3 * from score s--top n percent * 表示显示百分比select top 10 percent *from score *均为通配符 排序对搜索结果进行排序语法：12select * from score sorder by s.stuID dec,s.score asc desc 为降序 , asc为升序,默认为升序,如果第一个排序出现相同，则按第二个进行排序 字符连接可以将连个不同的列连接显示出来，注意，两个列表类型必须是字符，如果位int，则表示对int值进行运算。示例：12select studentInfo.stuName+&apos;--&apos;+subjects.subIDfrom studentInfo,subjects 联合查询将几个表中的数据同时查询并输出在一张表内。示例:123select stu.stuName 姓名,s.subID 科目,s.score 成绩from studentInfo stu, score s where s.stuID=stu.stuID 同时查询studentInfo与score中的数据，并且将学号对应后输出。 where字句 运算符where用来规定查找条件，后面跟布尔值，示例：123select *from scorewhere subID&gt;2 where 条件between 范围查找用来查找一定范围（条件）,还要一个not between,二者均包含给定值(&lt;=)。示例：123select *from score swhere s.score between 60 and 70 in 等于示例：123select *from score swhere s.score in (70,80) 查找s.score中值等于70或者80的。同样也有not in like [] 模糊查询示例：123select *from studentInfo stuwhere sut.stuName like &apos;[大二]师%&apos; 条件为，查询sut.stuName中第一个字为 大 或者 二，第二个字为师，之后为通配符，长度无所谓。 函数SUM 总和示例：123select SUM(score) 成绩总和from score swhere s.subID = 4 查询subID为4的科目所有人成绩的总和。 AVG 平均示例：123select AVG(score) 平均分from score s where s.subID = 4 求成绩平均分 MAX MIN示例：求最大最小123select MAX(score) 最大值from score s where s.subID = 4 这里只能用int COUNT示例：12select COUNT(*) 计数from studentInfo 统计学生个数。 group by 分组(having)对搜索后的结果进行分组，having表示对结果进行筛选示例：1234select s.subID,s.scorefrom score s group by s.subID,scorehaving s.subID&gt;2 示例部分显示加排序123select top 60 percent *from scoreorder by stuID desc 复合查询123select class as 班级 ,stuName as 姓名 ,subID as 科目,score.score as 成绩 from sutdentInfo , score where score.stuID=sutdentInfo.stuID order by score.subID desc","categories":[{"name":"学习相关","slug":"学习相关","permalink":"http://yoursite.com/categories/学习相关/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"},{"name":"SQL","slug":"SQL","permalink":"http://yoursite.com/tags/SQL/"}]},{"title":"SQL学习日记01","slug":"SQL学习日记01","date":"2019-02-28T08:06:21.000Z","updated":"2019-03-03T17:10:26.180Z","comments":true,"path":"2019/02/28/SQL学习日记01/","link":"","permalink":"http://yoursite.com/2019/02/28/SQL学习日记01/","excerpt":"我会在这里记录我的SQL学习记录，应该最近回定期更新，内容来源于互联网的各种帖子，已经老师课堂的教授，还有部分我自己的理解。","text":"我会在这里记录我的SQL学习记录，应该最近回定期更新，内容来源于互联网的各种帖子，已经老师课堂的教授，还有部分我自己的理解。 SQL定义SQL是英文Structured Query Language的缩写，意思为结构化查询语言。SQL语言的主要功能就是同各种数据库建立联系，进行沟通。 基础点SQL对大小写不敏感SQL查询或添加中所有汉字需要用单引号包裹SQL可以分为两部分：数据操作语言（MDL）和数据定义语言（DDL)SQL主要用来执行查询，而DDl则主要用来更改表格。 基础数据类型Char 固定长度非Unicode字符Vachar 可变长度非Unicode字符Text 长文本（最大255个字符）Ntext 可变长度文本（最大长度很大很大）Date/Time 日期/时间（目前还不知道咋用）Bit 布尔值（0/1）Nchar 固定长度Unicode字符Nvchar 可变长度Unicode字符Int 整数Float 浮点数什么是Unicode? 这写数据类型是用来定义表单中每一项数值的类型。 常见约束主键约束（Primary key constraint）将次字段设置为主键唯一约束（unique constraint）此字段中的值在表中不能有重复的检查约束（check constraint）设定几个检查值，该字段的值必须为设定的值之一默认约束（default constraint）就算不填写这个字段，也会生出一个默认值外键约束（foreign key constraint）将其与另一张表中的一个字段进行连接？且在从表中定义非空约束（not null）该字段必须填写 标识列/自增长被设定的字段将不允许被修改语法：1字段名 字段类型 identity(起始值，自增值) 基础语法注释1234-- 这是单行注释/*这是多行注释*/ 创建与删除数据库创建语法：12create database &lt;数据库名&gt;go 删除语法：12drop database &lt;数据库名&gt;go 删库跑路注意，go必须存在 切换操作数据库语法：12use &lt;数据库名&gt;go 用来切换之后指令执行的数据库 创建表语法：123456create table &lt;表名&gt;（ 字段名1 数据类型 约束 字段名2 数据类型 约束 字段名n 数据类型 约束） 添加约束语法：12alter lable &lt;表名&gt;add constraint 约束名 约束类型 具体说明 约束名一般为：约束的首字母大写_表名 Select 查找Select语句用来从表中选区数据。结果回输出在一个表中语法：12SELECT 列名称 FROM 表名称SELECT * FROM 表名称 示例：1select * from studentInfo where stuSex=&apos;男&apos; ‘ *’ 表示在当前列下进行查找 Insert 插入语法：1insert [into] &lt;表名&gt; [列名] values &lt;值列表&gt; 示例：12insert students (stuSex,stuName,stuAge) values (男，滑稽，18)，insert students (tuName) values (滑稽),(大滑稽),(小滑稽) 上面的例子是两种插入方式。注： - 字段名顺序要和值顺序一致。 - 数据类型一一对应。 - 有非空的字段必须插入数值 - 必须遵信其他约束 Update 修改语法：1update &lt;表名&gt; set &lt;列明 = 更新值&gt; [where 更新条件] 示例：1update sutdents set stuSex=&apos;女&apos; where sutSex=&apos;男&apos; 删除语法：1delete from &lt;表名&gt; [where 条件表达式] 示例：1delete from sutdents where stuName=&apos;滑稽&apos; 杂谈这是这学期开学第一周所学习的SQL基础，真的非常基础，看起来SQL没有什么太过于难思考的地方，现在面临的一个小问题就是这写单词比较难记忆。这毕竟是交互的基础，所有认真一点，不懂就问。","categories":[{"name":"学习相关","slug":"学习相关","permalink":"http://yoursite.com/categories/学习相关/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"},{"name":"SQL","slug":"SQL","permalink":"http://yoursite.com/tags/SQL/"}]},{"title":"MarkDown的一些用法","slug":"MarkDown的一些用法","date":"2019-02-20T11:59:43.000Z","updated":"2019-02-21T13:02:48.166Z","comments":true,"path":"2019/02/20/MarkDown的一些用法/","link":"","permalink":"http://yoursite.com/2019/02/20/MarkDown的一些用法/","excerpt":"因为在写Blog的时候要使用MarkDown，所以我将一些基本语法写在这里，方便我日后翻阅，这是MarkDown中文网的教程。","text":"因为在写Blog的时候要使用MarkDown，所以我将一些基本语法写在这里，方便我日后翻阅，这是MarkDown中文网的教程。 什么是MarkDown？Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。 语法一、标题在想要设置为标题的文字前加#来表示其为标题，标题分为六级，一个#为一级，两个#为二级，以此类推。注：在#后加一个空格再写文字。例子： #一级标题 ###三级标题 ######六级标题 二、正文以及字体MarkDown的文字是直接写出的，不需要任何特殊标记。 ·加粗要加粗的文字左右用两个 * 包起来 ·斜体要倾斜的文字左右用一个 * 包起来 ·斜体加粗要斜体加粗的文字左右分别用三个 * 包起来，其实就是斜体加粗的重叠 ·删除线要加删除线的文字左右分别用两个 ~~ 包起来 #####整体示例加粗倾斜倾斜加粗删除线 三、引用再引用的文字前加&gt;即可。引用也可以嵌套。 ####示例 一级引用 二级引用 三级引用 四、分割线三个或三个以上的-或者*都可以。为了规范写作，我建议使用-。示例：下面这个就是分割线 五、图片语法：1![图片下显示的文字](图片地址) 示例： 布洛妮娅 六、超链接语法：1[超链接名](超链接地址) 示例：百度 七、列表·无序列表无序列表用 - + * 任何一种都可以，注意空格。123- 列表内容+ 列表内容* 列表内容 例子： 苹果 橘子 香蕉·有序列表语法：数字加点1231.列表内容2.列表内容3.列表内容 示例：1.苹果2.橘子3.香蕉吐槽：看着没啥用。 八、表格语法：1234表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容 第二行用来分割表头和内容。其中的-有一个就行，为了美观，多加了几个。示例：姓名|性别|年龄—|:–:|—:滑稽|未知|你猜阿福|扶她|18目测在我这没法加载 九、代码区语法：单行代码：代码之间用反引号包起来1&apos;代码内容&apos; 代码块：代码之间用三个反引号包起来，且两边的反引号单独占一行。12345(```) 代码 代码 代码(```) 因为显示原因反引号处加了小括号 示例：int abc;123int a; int b;int c; 所感写到这里所有的基础格式就结束了，下面是我的一些见解。我得承认在hexo这种形式的网页生成中，MarkDown确实是一个非常好的工具，同时MarkDown本身也是非常易学易用，同时足够强大。不过比较讨厌许多必须存在的空格。再写这篇文章时听完了VG聊天室200期，去他妈的圣歌，Apex牛逼。","categories":[{"name":"学习相关","slug":"学习相关","permalink":"http://yoursite.com/categories/学习相关/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"},{"name":"MarkDown","slug":"MarkDown","permalink":"http://yoursite.com/tags/MarkDown/"}]},{"title":"我的第一篇blog","slug":"我的第一篇blog","date":"2019-02-20T09:39:23.000Z","updated":"2019-02-20T13:33:15.062Z","comments":true,"path":"2019/02/20/我的第一篇blog/","link":"","permalink":"http://yoursite.com/2019/02/20/我的第一篇blog/","excerpt":"介绍我是谁我是一明很普通的学生，热爱瞎搞，对大多数事物都有足够的好奇心，但是又有些三分热度。在电脑硬件方面比较精通，乐于去*修电脑*。目前在大学学习计算机方面的专业。","text":"介绍我是谁我是一明很普通的学生，热爱瞎搞，对大多数事物都有足够的好奇心，但是又有些三分热度。在电脑硬件方面比较精通，乐于去*修电脑*。目前在大学学习计算机方面的专业。 这个Blog是干嘛的这是我个人的博客，应该会不定期我也不知道我有没有恒心写下去的更新一些最近的所见所想，或者有关我个人近期学习的一些东西，或者是毫无意义但是我就是想写出来的东西 其他一些事情Blog的搭建这个Blog使用hexo搭建，这应该是我第三次，也是第二次成功将他打建成可以使用的Blog，在这个长达至少两年的过程中，我要感谢@Grover等我想起他的Blog我会回来改的的帮助。同时，这个Blog使用了yscoder大大的主题，我将其进行了一定的修改，也感谢大大的规范代码没有对我造成过多的修改困难。 其他的其他如果您对我的博客，或者我个人有任何问题或单纯的想认识一下我，请致电我的邮箱。","categories":[{"name":"杂七杂八的东西","slug":"杂七杂八的东西","permalink":"http://yoursite.com/categories/杂七杂八的东西/"}],"tags":[{"name":"不知道贴什么标签","slug":"不知道贴什么标签","permalink":"http://yoursite.com/tags/不知道贴什么标签/"},{"name":"日常","slug":"日常","permalink":"http://yoursite.com/tags/日常/"}]}]}